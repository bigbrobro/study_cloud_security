# 一、云原生技术包括哪些

## 1、1 容器技术

​	容器和虚拟化

​	容器镜像

​	容器存储

​	容器网络

​	容器运行时

## 1、2 容器编排

## 1、3 微服务



# 二、容器技术脆弱性

我们从容器镜像、运行时容器、容器网络、容器管理接口、宿主机操作系统这5个方面来分析容器技术的脆弱性和攻击面。

## 2、1 静态容器镜像的脆弱性

所有容器都来自容器镜像，所有先研究容器镜像的风险。

### 1、不安全的第三方组件

在实际的容器化应用开发过程中，很少从零构建自己的业务镜像，而是将Docker Hub上的镜像作为基础镜像，在此基础上增加自己的代码或程序，然后打包成最终的业务镜像并上线运行。用户的代码依赖若干开源组件，开源组件本身有着复杂的依赖树，导致最终包含的组件非常多。组件越多，可能存在的风险和漏洞就越多。



### 2、恶意镜像

以Docker Hub为代表的公共镜像仓库中还可能存在一些恶意镜像。如果使用这些镜像作为基础镜像，那么风险不言自明。



### 3、泄露敏感信息

​	为了开发、调试方便，开发者可能会将敏感信息-如数据库密码、证书和私钥等内容直接写到代码中，或者以配置文件形式存放。构建镜像时，这些敏感内容被一并打包到镜像中，从而造成敏感数据泄露。



## 2、2 运行时容器的脆弱性

### 1、不安全的容器应用

容器黄金下的业务代码本身可能存在bug甚至安全漏洞。容器技术并不能解决这些问题。无论是SQL注入、XSS和文件上传漏洞，还是反序列化或缓冲区溢出漏洞，他们都有可能出现在容器化应用中。



### 2、不受限制的资源共享

既然容器运行宿主机上，容器必然要使用宿主机提供的各种资源——计算资源、存储资源等。如果容器使用了过多资源，就会对宿主机及宿主机上的其他容器造成影响，设置形成资源耗尽型攻击。

在默认情况下，Docker并不会对容器的资源进行限制。也就是说可以无限使用宿主机上的CPU、内存、硬盘等资源。



### 3、不安全的配置和挂载

容器的核心是两大隔离机制：

**Linux命名空间机制**：在文件系统、网络、进程、进程间通信和主机名等方面实现隔离。

**cgroups机制**：在CPU、内存和硬盘等资源方面实现隔离。

为什么配置和挂载会导致风险呢？因为会导致容器的隔离性被打破

- 通过配置--privileged选项，容器内root权限将变得和宿主机上root差不多。
- 通过配置--net=host，容器将与宿主机处于同一网络命名空间（网络隔离被打破）
- 通过配置--pid=host，容器将与宿主机处于同一进程命名空间（进程隔离被打破）
- 通过执行挂载--volume /:/host，宿主机根目录将被挂载到容器内部（文件系统隔离被打破）



## 2、3 容器网络脆弱性

每个容器都处于由docker网桥构建的同一个局域网内，彼此之间互通，类似局域网，容器内的root用户虽然被Docker禁用了很多权限（Cap机制），但它目前依然具有CAP_NET_RAW权限，具备构造和发送ICMP、ARP等报文的能力。所以在局域网内常见的arp欺骗、dns劫持、中间人攻击等都可能发生在容器网络中。



容器网络接口CNI是现行的网络接口标准，CNI接口只实现创建、删除容器时的调用方法，其他所有网络能力都交由网络厂商实现增值服务，在一定程度上加速了网络方案的繁荣。



根据网络协议的不同，可将网络方案分为路由模式、Overlay和L2方案三种。

![image-20220603150359052](picture/image-20220603150359052.png)

这块稍微讲下微隔离技术，正好宣传下我司产品。



## 2、4 容器管理接口脆弱性

Socker是Docker守护进程接收请求及返回响应的应用接口。

Docker守护进程主要监听两种形式的Socket：Unix socket和TCP socket。安装启动后，默认情况下Docker守护进程只监听Unix socket。

### 1、Unix socket

为什么Unix socket存在风险呢？

Docker守护进程默认以宿主机root权限运行。只要能够与该Unix socket进行交互，就可以借助其root权限在宿主机上执行任意命令。

相关的风险利用场景主要有两个：

1） 用户为了方便，不想每次输入密码时都使用sudo或su，将普通用户也加入了docker用户组，这使得普通用户有权限直接访问Unix socket。那么一旦攻击者获得这个普通用户的权限，就能够借助Docker Unix socket在宿主机上提升为root权限。

2）为了实现在容器内管理容器，用户可能会将Docker Unix socket挂载到容器内部。如果该容器被入侵，攻击者就能借助这个socket实现容器逃逸，获得宿主机的root权限。



### 2、TCP socket

在新版Docker中，Docket守护进程默认不会监听TCP socket。用户可以通过配置文件来开启对TCP socket的监听。

默认情况下，对Docket守护进程TCP socket的访问是无加密且无认证的。因此，任何网络可达的访问者都可以通过该TCP Socket来对Docker守护进程下发命令。例如，以下命令列出ip为192.168.1.101的主机上所有活动容器：

docker -H tcp:192.168.1.101:2375 ps

显而易见，攻击者也可以通过TCP socket对宿主机的Docker 守护进程下发命令，从而实现对宿主机的控制。



## 2、5 宿主机操作系统脆弱性

容器安全从字面意思是限于容器范围，但其是以宿主机或虚拟机为基础设施底座的。这块其实涉及到主机安全的事。

如果容器运行所在的主机（例如Kubernetes工作节点）遭到入侵，则可能会导致：

- 通过提权、实现root用户权限
- 窃取用于访问安全应用或基础结构的秘钥
- 更改集群管理员权限
- 主机资源损坏或劫持（例如挖矿软件）
- 影响关键编排工具基础架构，例如API Server或Docker守护程序

## 2、6 从BUILD、SHIP、RUN角度来分析





# 三、容器攻击面

## 3、1针对容器软件供应链的攻击面

容器镜像时软件供应链中非常重要的一部分。人们可从Docker Hub或第三方仓库中拉取镜像，在其基础上进行开发，从而实现其功能，最后打包发布。

然而业务依赖的基础镜像可能存在问题——无论是开发者无心导致的安全漏洞，还是攻击者故意留下的恶意代码。

下面介绍两种类型的容器软件供应链攻击：镜像漏洞利用和镜像投毒。

### 1、镜像漏洞利用

镜像本身存在漏洞时，使用镜像创建并运行的容器也通常会存在相同漏洞，攻击者利用此漏洞去攻击容器。



### 2、镜像投毒

​	投放恶意挖矿镜像

​	投放恶意后门镜像

​	投放恶意exploit镜像



## 3、2 容器逃逸

### 1、不安全配置导致的容器逃逸

Docker默认禁用了所有Capabilities，再以白名单方式赋予容器运行所需的最小权限。Docker默认赋予容器近40项权限中的14项：

但是用户可以通过修改容器环境配置或在运行容器时指定参数来调整约束，比如如下配置就可能引起容器逃逸。



**--privileged: 特权模式运行容器**

当操作者执行docker run --privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，将使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限。



### 2、不安全挂载导致的容器逃逸

为了方便宿主机和虚拟机进行数据交换，几乎所有主流虚拟机解决方案都会提供挂载宿主机目录到虚拟机的功能。容器同样如此。

**挂载Docker Socket的情况**

​	Docker socket是Docker守护进程监听的Unix域套接字，用来与守护进程通信——查询信息或下发命令。



**挂载宿主机procfs的情况**

​	procfs是一个虚拟文件系统，它动态的反映系统内进程以及其他组件的状态，其中含有很多敏感、重要的文件。



## 3、3 资源耗尽型攻击

使用VMware、VirtualBox时，我们都需要明确为即将创建的虚拟机设置明确的CPU、内存、磁盘等资源的阈值。

然而容器运行时默认情况下并未对容器内进程在资源使用上做任何限制，以Pod为单位的Kubernetes编排管理系统在默认情况下，同样未对用户创建的POD做任何CPU、内存使用限制。

攻击者可在一个容器内占用大量宿主机资源，从而影响到宿主机自身或宿主机上其他容器的正常运行。

常见受影响的资源如下：

1）计算资源：CPU、内存

2）存储资源：本地硬盘

3）内核维护的数据结构（进程表等）

4）通信资源：网络带宽等



# 四、容器编排平台的脆弱性

## 4、1 容器编排平台概述

先讲解下kubernetes的大致架构，铺垫下。

![image-20220603172522879](picture/image-20220603172522879.png)

图示为一个常见的Kubernetes集群，有一个Master节点和两个Worker节点组成，Pod之间借助CNI插件Flannel实现通信。



对比容器镜像脆弱性的不安全第三方组件、恶意镜像、泄露敏感信息。Kubernetes提供了ConfigMaps和Secrets两种资源来单独存储常规配置和敏感信息。所以在Kubernetes平台下，讲敏感信息打包进镜像的情况可能会减少，但是依旧存在。

## 4、2 Kubernetes组件接口脆弱性

Kubernetes绝大多数组件以http或https的API形式提供服务

| 组件       | 默认端口 | 说明                              |
| ---------- | -------- | --------------------------------- |
| API Server | 6443     | 基于https的安全端口               |
| API Server | 8080     | 不安全的http端口，不建议启用      |
| Kubelet    | 10248    | 用于检查kubelet健康状态的http端口 |
| Kubelet    | 10250    | 面向api server提供服务的https端口 |
| Dashboard  | 8001     | 提供http服务的端口                |
| etcd       | 2379     | 客户端和服务端之间通信的端口      |
| etcd       | 2380     | 不同服务端实例之间通信的端口      |

### 1、API Server

### 2、Dashboard

### 3、Kubelet

### 4、etcd

​	Kubernetes集群内的各种资源及其状态均存储在etcd中。如有办法获取etcd中的数据，就有可能获取高权限，从而控制集群。



## 4、3 集群网络的脆弱性

Kubernetes使用CNI网络插件，如Flannel、Calico、Cilium来实现集群POD之间的通信。

在没有其他网络隔离策略和Pod安全策略的默认情况下，Pod内的root用户具有CAP_NET_RAW权限，集群内部可能发生网络探测、嗅探、ddos、中间人攻击等网络攻击。



## 4、4 访问控制机制的脆弱性

Kubernetes中的访问控制机制，主要由认证机制、授权机制、准入控制三方部分组成。

即使认证和授权机制在容器环境创建初期遵循最小权限等安全原则，随着时间的推移和环境的变动更新，角色和权限可能会变得混乱，给攻击者以可乘之机。



# 五、容器编排平台的攻击面

## 5、1 针对Kubernetes组件不安全配置的攻击面

Kubernetes API Server未授权访问

Kubernetes Dashboard未授权访问

Kubernetes kubelet未授权访问

## 5、2 针对Kubernetes权限提升的攻击面

## 5、3 针对Kubernetes的拒绝服务的攻击面



# 六、个人建议

通过DevSecOps技术，尽早在容器生命周期中引入安全，这种方法将安全嵌入到整个容器生命周期中：构建、部署和运行。